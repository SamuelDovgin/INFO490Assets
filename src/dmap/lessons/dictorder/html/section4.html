<!DOCTYPE html><html lang='en'><head><meta charset="utf-8"><style>/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}h1{font-size:2em;margin:.67em 0}pre{font-family:monospace,monospace;font-size:1em}strong{font-weight:bolder}code{font-family:monospace,monospace;font-size:1em}img{border-style:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}blockquote,h1,h2,p,pre{margin:0}html{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";line-height:1.5}*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e2e8f0}img{border-style:solid}h1,h2{font-size:inherit;font-weight:inherit}code,pre{font-family:Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}img{display:block;vertical-align:middle}img{max-width:100%;height:auto}.bg-gray-200{--bg-opacity:1;background-color:#edf2f7;background-color:rgba(237,242,247,var(--bg-opacity))}.bg-gray-300{--bg-opacity:1;background-color:#e2e8f0;background-color:rgba(226,232,240,var(--bg-opacity))}.border-gray-500{--border-opacity:1;border-color:#a0aec0;border-color:rgba(160,174,192,var(--border-opacity))}.rounded{border-radius:.25rem}.rounded-full{border-radius:9999px}.border-solid{border-style:solid}.border-t{border-top-width:1px}.inline-block{display:inline-block}.flex{display:flex}.justify-center{justify-content:center}.justify-around{justify-content:space-around}.font-serif{font-family:Georgia,Cambria,"Times New Roman",Times,serif}.font-semibold{font-weight:600}.font-bold{font-weight:700}.h-48{height:12rem}.h-64{height:16rem}.text-sm{font-size:.875rem}.text-base{font-size:1rem}.text-xl{font-size:1.25rem}.m-2{margin:.5rem}.mr-2{margin-right:.5rem}.mb-3{margin-bottom:.75rem}.ml-3{margin-left:.75rem}.max-w-sm{max-width:24rem}.object-contain{-o-object-fit:contain;object-fit:contain}.overflow-hidden{overflow:hidden}.p-1{padding:.25rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.px-3{padding-left:.75rem;padding-right:.75rem}.py-4{padding-top:1rem;padding-bottom:1rem}.px-4{padding-left:1rem;padding-right:1rem}.px-6{padding-left:1.5rem;padding-right:1.5rem}.pl-3{padding-left:.75rem}.shadow-lg{box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.05)}.text-center{text-align:center}.text-gray-700{--text-opacity:1;color:#4a5568;color:rgba(74,85,104,var(--text-opacity))}.text-gray-800{--text-opacity:1;color:#2d3748;color:rgba(45,55,72,var(--text-opacity))}.w-full{width:100%}.text-tiny{font-size:.5rem!important}.lesson{padding-left:10px;padding-right:10px;--bg-opacity:1;background-color:#edf2f7;background-color:rgba(237,242,247,var(--bg-opacity))}p.new{padding-top:.5em;padding-bottom:.5em}h1{margin-top:1.5em;font-weight:700;font-family:Georgia,Cambria,"Times New Roman",Times,serif!important}h2{margin-top:1em;font-weight:700;font-family:Georgia,Cambria,"Times New Roman",Times,serif!important}blockquote{font-size:1em;background:#f9f9f9;border-left:10px solid #ccc;margin:1.5em 10px;padding:.5em 10px;border-left-color:#ffcd69;border-right-color:#f6ba59;quotes:"\201C""\201D""\2018""\2019"}blockquote:before{color:#ccc;content:open-quote;font-size:4em;line-height:.1em;margin-right:.25em;vertical-align:-.4em}blockquote p{display:inline}p img:not(.jax){width:66.666667%;margin-left:1.25rem}code{font-size:14px}pre code{background:#f4f4f4;font-family:monospace;font-size:14px;border:1px solid #ddd;color:#666;page-break-inside:avoid;min-width:710px;max-width:710px;line-height:1.6;margin-bottom:1.6em;padding:1em 1.5em;display:block;-moz-tab-size:2;-o-tab-size:2;tab-size:2;overflow-x:auto;word-wrap:break-word;white-space:pre-wrap;border-left:3px solid #f36d33}div.code-starter pre code{border-left:1px solid #3346f3!important}
div.code-starter {display:none;}</style><script src="https://kit.fontawesome.com/7efc4bcee2.js" crossOrigin="anonymous"></script></head><body class = "lesson apples "><div class="main-content bg-gray-200 p-1 pl-3 text-xl font-serif"><div><h1 class="section" id="section5"> </h1><p class="new">As a reminder, the <code>keys()</code> method returns a view into the dictionary NOT a list of strings.
Luckily, the <code>sorted</code> function takes an <em>iterable</em> as its parameter.</p><h2 id="sorting-the-dictionary-values">Sorting the dictionary values</h2><p class="new">You can also sort the dictionary values:</p><pre><code>simple = {"apples":5, "pears":2, "bananas":12}

for v in sorted(simple.values()):
  print(v)</code></pre><p class="new">However, note that the method <code>values()</code> is only a set of values, at this point you no 
longer know what key is associated to each value.</p><h2 id="sorting-the-key-value-pairs">Sorting the key, value pairs</h2><p class="new">To fix the problem noted above, you can ask the dictionary for all of its key/value pairs 
using the <code>items()</code> method. 
```
simple = {"apples":5, "pears":2, "bananas":12}</p><p class="new">for t in sorted(simple.items()):
  # t is a tuple 
  # t[0] is the key, 
  # t[1] is the value
  print(t[0], t[1])
```</p><p class="new">The <code>sorted</code> function is now working with a collection of tuples.  The default 
value to use for sorting is the first item of the tuple (or sequence type). 
The key is at index 0 (the first item of the tuple) and the value is at index 1 
(the second item of the tuple). </p><p class="new">The following figure shows an example dictionary and what the methods <code>items()</code>, <code>keys()</code>, and <code>values()</code> returns:
<img alt="table" src="https://github.com/NSF-EC/INFO490Assets/raw/master/src/dmap/lessons/dictorder/html/table.jpeg"/></p><h2 id="using-a-helper-function">Using a helper function</h2><p class="new">Note that the dictionary is being sorted by the key (the name of the fruit).  If you want to sort by values instead, you have to create a special function to give to the sorted function (using the key named parameter):</p><h2 id="sorted-by-value-using-the-key">Sorted by value, using the key</h2><pre><code>simple = {"apples":5, "pears":2, "bananas":12}

def by_value(key):
  # the key is a string (e.g. 'apples')
  # return the count 
  return simple[key]

for k in sorted(simple.keys(), key=by_value):
  print(k, simple[k])</code></pre><p class="new">The function <code>by_value</code> is called a helper function since it "helps" the sorted function 
find the values to use to compare.</p><h2 id="sorted-by-value-using-the-item-pair">Sorted by value, using the item pair</h2><p class="new">Since <code>items()</code> returns a list of tuples, the sort function will be passed a tuple.<br/>So the sort function just returns the part of the tuple that holds the value</p><pre><code>simple = {"apples":5, "pears":2, "bananas":12}

def by_value(tuple_item):
  return tuple_item[1]

for t in sorted(simple.items(), key=by_value):
  print(t[0], t[1])</code></pre><p class="new">Since <code>items</code> is an iterator over key/value pairs, each item is then passed to the function <code>by_value</code>.  This function is receiving a tuple. </p><h2 id="complex-dictionaries">Complex Dictionaries</h2><p class="new">Just like any value inside a list can be any valid Python type (e.g. another list, a dictionary, a function, a number, a string, etc), the values of a dictionary can be any valid type as well.  In the example below the value for each key is another dictionary with two keys:</p><pre><code>complex_map = {
   "apples":  {"count": 12, "calories": 200},
   "pears":   {"count": 2,  "calories": 100},
   "bananas": {"count": 5,  "calories": 300}
}
print(complex_map["apples"]["calories"])</code></pre><p class="new">Note that the keys of the complex dictionary are still strings or numbers, however, each value is yet another dictionary.  So complex_map["apples"] returns a dictionary with two keys: count and calories.  With this recursive definition (a dictionary inside another dictionary), you can build very complex and useful containers to hold our application data.</p><h2 id="complex-dictionaries-complex-sorting">Complex Dictionaries, Complex Sorting</h2><p class="new">When the dictionary has a complex structure, sorting becomes complex.  As mentioned before the sorting function can only work with very simple values.  If you have a complex dictionary, you need to write a helper function that the sorting function will use to return the value to be used for sorting.  </p><p class="new">Let's look at an example.  First you need to determine how you want to sort our dictionary.  Let's sort the dictionary based on the number of fruits (the count key)  So you need to write a function that takes a dictionary key (a string) and returns the correct value to sort on.  The function by_count shown below does that.
def by_count(key):
  return complex_map<span>[key]["count"]</span></p><p class="new">Now you can call the sorted function passing by_count as an argument to the sorted function:
sorted(complex<em>map.keys(), key=by</em>count)</p><p class="new">So here's what it looks like all together:
complex_map = {
"apples":  {"count": 12, "calories": 200},
"pears":   {"count": 2,  "calories": 100},
"bananas": {"count": 5,  "calories": 300}
}</p><p class="new">def by_count(key):<br/>  # note this function is accessing
  # a global variable (not good)! 
  return complex_map<span>[key]["count"]</span> </p><p class="new">for k in sorted(complex<em>map.keys(), key=by</em>count):
  print(k, complex_map[k])</p><p class="new">Note the output.  The outer dictionary is sorted by a value inside the inner dictionary.
Coder's Log: The sorted function needs a list of things to sort.  The helper function that is passed in is always given a single item from that list passed in.  Your helper function is used to determine how to get a value that can be used for sorting from the item.
Fixing the 'global' sort
The problem with this sort is the sorting function by<em>count needs to access the variable that points to the dictionary (i.e. complex</em>map).  In general, when you write functions, you don't want the function to access variables outside the scope of the function (i.e. global variables).  It makes it difficult to test as well as to update and maintain the code.</p><p class="new">As you saw, the dictionary method items() returns each of the dictionary components as (key, value) pairs as a tuple.  The key is at index 0 and the value is at index 1.  Now the sorting function you pass into the sorted function (using the named parameter key) will accept a tuple (since that's what you are sorting):
def by_count(t):
  # t is a tuple 
  # t[0] is the key
  # t[1] is the value
  data = t[1]
  return data["count"]</p><p class="new">for v in sorted(complex<em>map.items(), key=by</em>count):
  print(v)</p><p class="new">Be sure you understand the above code.</p><p class="new">For sorting dictionaries, you can work with the keys, values, or key/value pairs.  In most cases you won't use the values() method, since there's no way to get the matching keys.</p><p class="new">Exercise:
Change the by_count function above but to sort the fruit list by calories.</p><p class="new">Revisiting Lamda Functions
In the previous lesson, you introduced the idea of using an inline lambda function to pass to the sorted function.  As you may remember a lambda function is just an unnamed (sometimes called anonymous) function.</p><p class="new">As previously mentioned, a benefit of lambda functions is they don't pollute the name space of a Python program (the name space defines what variables and functions are visible to use).  If a function is ONLY going to be used for a specific sorting purpose, there's no reason to make it visible to other functions. </p><p class="new">You can use a lambda function to create an inline function.
for v in sorted(complex_map.items(), 
           key=lambda item: item<span>[1]["count"]</span>):
  print(v)</p><p class="new">The great feature of lambda functions is that the dependance on the data is right there -- where it is being used.  If you changed the structure of your dictionary, it's easy to figure out what needs to be updated in the respective sorting operation.</p><p class="new">As a reminder, both functions below are functionally/semantically equivalent:
def is_odd1(x):
  return x%2 == 1</p><p class="new">is_odd2 = lambda x : x%2 == 1
print(is<em>odd1(3) == is</em>odd2(3))</p><p class="new">Lesson Assignment
Place all your code in lesson.py module</p><p class="new">Part 1: Apple Modeling</p><p class="new">Below are the parallel arrays that track a different attribute of the apples (note that the above chart (Sweet-Tart Chart) doesn't align with the data from the previous lesson):
names = ["McIntosh", "Red Delicious", 
         "Fuji", "Gala", "Ambrosia", 
         "Honeycrisp", "Granny Smith"]
sweetness = [3, 5, 8, 6, 7, 7.5, 1]
tartness  = [7, 1, 3, 1, 1, 8,   10]</p><p class="new">Step 1:  Data Model (parallel arrays to dictionary)
Build a dictionary named apples.  The apple dictionary keys will be the names of the apples. The values will be another dictionary.  This value dictionary will have two keys: "sweetness" and "tartness".  The values for those keys will be the respective values from the sweetness and tartness lists given above.  You will build this by defining a variable named apples (see the complex_map example).</p><p class="new">This is why dictionaries are also called associative arrays.  The arrays need to be kept in order so they can associate the same index with the same corrresoponding value that make holding this kind of data easier. </p><p class="new">Step 2: Apple Aid
Now that you have our model, create a function named by<em>sweetness whose parameter will be a tuple (from apples.items()) The function by</em>sweetness will return the sweetness value of the incoming tuple.  This helper function cannot reference the global variable apples (from step 1).</p><p class="new">Create another function by<em>tartness that is essentially the same as by</em>sweetness but returns the tartness value of the incoming tuple.</p><p class="new">Step 3:  Apple Sorting
Write a function called apple<em>sorting that has two parameters: data (the data model dictionary) and sort</em>helper (the function used to sort the model).  The apple<em>sorting should use the sorted function to sort the data (e.g. data.items()) with sort</em>helper.  The function returns a list of tuples in order of their sweetness (sweetest apples listed first).</p><p class="new">Once done, this should work:
print(apple<em>sorting(apples, by</em>sweetness))</p><p class="new">Coder's Log:  You may have noticed that several apples have the same tartness level (e.g. 1).  It's possible that you will get different sort orders because of how 'ties' are broken.  This is called unstable sorting -- sorting that is not stable between runs.  The tests make sure this won't happen.</p><p class="new">Part 2:
Create a function sort<em>by</em>total_calories.  This function takes a single parameter that's a dictionary defined as follows:
data = {
"apples":  {"count": 12, "calories": 200},
"pears":   {"count": 2,  "calories": 100},
"bananas": {"count": 5,  "calories": 300}
}</p><p class="new">The function returns a list of tuples.  The first element of the tuple is the key (e.g. "apple") and the second element is the total calories (count * calories).  </p><p class="new">So the function sort<em>by</em>total_calories() returns the list in descending order of total calories for each item.  For the above data, the returned list would be:[('apples', 2400), ('bananas', 1500), ('pears', 200)]</p><p class="new">def sort<em>by</em>total_calories(v):</p></div></div></body></html>